package xjsnark.gcm;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import java.util.Arrays;
import backend.auxTypes.UnsignedInteger;
import util.Util;
import backend.eval.CircuitEvaluator;

public class GCM extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see other examples) 
    Config.writeCircuits = true;
    Config.outputFilesPath = "/home/deepak/Desktop/candid/circuits/";
    new GCM();
  }

  public GCM() {
    super("GCM");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {

        // assigning values to inputs 
        BigInteger keyV = new BigInteger("1d31d2ab2e9231841148117f562f5669", 16);
        BigInteger msgV = new BigInteger("485454502f312e3120323030204f4b0d", 16);
        BigInteger ctrV = new BigInteger("4e5651eb794ba44cc494895700000002", 16);
        BigInteger icbV = new BigInteger("4e5651eb794ba44cc494895700000001", 16);
        byte[] keyArray = keyV.toByteArray();
        byte[] msgArray = msgV.toByteArray();
        byte[] ctrArray = ctrV.toByteArray();
        byte[] icbArray = icbV.toByteArray();
        // First byte is zero (sometimes?) 
        keyArray = Arrays.copyOfRange(keyArray, keyArray.length - 16, keyArray.length);
        msgArray = Arrays.copyOfRange(msgArray, msgArray.length - 16, msgArray.length);
        ctrArray = Arrays.copyOfRange(ctrArray, ctrArray.length - 16, ctrArray.length);
        icbArray = Arrays.copyOfRange(icbArray, icbArray.length - 16, icbArray.length);
        for (int i = 0; i < plaintext.length; i++) {
          plaintext[i].mapValue(BigInteger.valueOf((msgArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        for (int i = 0; i < key.length; i++) {
          key[i].mapValue(BigInteger.valueOf((keyArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        for (int i = 0; i < counter.length; i++) {
          counter[i].mapValue(BigInteger.valueOf((ctrArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        for (int i = 0; i < initialCounter.length; i++) {
          initialCounter[i].mapValue(BigInteger.valueOf((icbArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
      }
      public void post() {
        System.out.println("Circuit Output: ");
        for (int i = 0; i < ciphertext.length; i++) {
          System.out.print(ciphertext[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).toString(16) + " ,");
        }
        System.out.println();
        for (int i = 0; i < hashkey.length; i++) {
          System.out.print(hashkey[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).toString(16) + " ,");
        }
        System.out.println();
        for (int i = 0; i < hashkey1.length; i++) {
          System.out.print(hashkey1[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).toString(16) + " ,");
        }
        System.out.println();
        System.out.println("Expected Output: d9964146d5efcb358df9dfef0212f32c\n HashKey: 2de0508ea34fbe38356341014c7cb2b0\n H1: 5470e53ba93dc00a45c6b1d3212aed87");
      }

    });

  }



  public void __init() {
    plaintext = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
    ciphertext = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
    key = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
    counter = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
    hashkey = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
    hashkey1 = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
    initialCounter = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
  }

  private UnsignedInteger[] plaintext;
  private UnsignedInteger[] ciphertext;
  private UnsignedInteger[] key;
  private UnsignedInteger[] counter;
  private UnsignedInteger[] hashkey;
  private UnsignedInteger[] hashkey1;
  private UnsignedInteger[] initialCounter;

  @Override
  public void __defineInputs() {
    super.__defineInputs();











  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, ciphertext);
    UnsignedInteger.makeOutput(this, hashkey);
    UnsignedInteger.makeOutput(this, hashkey1);







  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();




    plaintext = (UnsignedInteger[]) UnsignedInteger.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(plaintext), 8);
    key = (UnsignedInteger[]) UnsignedInteger.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(key), 8);
    counter = (UnsignedInteger[]) UnsignedInteger.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(counter), 8);
    initialCounter = (UnsignedInteger[]) UnsignedInteger.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(initialCounter), 8);











  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();












  }
  public void outsource() {
    AES128Encrypt encryptor = new AES128Encrypt(key);
    ciphertext = encryptor.encrypt(counter);

    for (int i = 0; i < ciphertext.length; i++) {
      ciphertext[i].assign(plaintext[i].xorBitwise(ciphertext[i]), 8);
    }

    AES128Encrypt encryptor1 = new AES128Encrypt(key);
    hashkey = encryptor1.encrypt(hashkey);

    AES128Encrypt encryptor2 = new AES128Encrypt(key);
    hashkey1 = encryptor2.encrypt(initialCounter);
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
