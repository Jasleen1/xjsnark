package xjsnark.aesDecryption;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.util.Arrays;
import java.math.BigInteger;
import backend.auxTypes.UnsignedInteger;
import backend.eval.CircuitEvaluator;

public class Main extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see other examples) 
    Config.writeCircuits = true;
    Config.outputFilesPath = "/home/deepak/Desktop/candid/circuits/";
    // set the path of the output circuit 


    new Main();
  }

  public Main() {
    super("Main");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {

        // assigning values to inputs 
        byte[] keyArray = fromHexString("000102030405060708090a0b0c0d0e0f");
        byte[] msgArray = fromHexString("69c4e0d86a7b0430d8cdb78070b4c55a");
        msgArray = Arrays.copyOfRange(msgArray, msgArray.length - 16, msgArray.length);
        keyArray = Arrays.copyOfRange(keyArray, keyArray.length - 16, keyArray.length);
        for (int i = 0; i < ciphertext.length; i++) {
          ciphertext[i].mapValue(BigInteger.valueOf((msgArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        for (int i = 0; i < key.length; i++) {
          key[i].mapValue(BigInteger.valueOf((keyArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
      }
      public void post() {
        System.out.println("Circuit Output: ");
        for (int i = 0; i < key.length; i++) {
          System.out.print(plaintext[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).toString(16) + " ,");
        }
        System.out.println();
        System.out.println("Expected Output: 00112233445566778899aabbccddeeff");
      }

    });

  }



  public void __init() {
    plaintext = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
    ciphertext = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
    key = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 8);
  }

  private UnsignedInteger[] plaintext;
  private UnsignedInteger[] ciphertext;
  private UnsignedInteger[] key;

  @Override
  public void __defineInputs() {
    super.__defineInputs();
    ciphertext = UnsignedInteger.createInputArray(this, ciphertext.length, 8);
    key = UnsignedInteger.createInputArray(this, key.length, 8);







  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, plaintext);







  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();










  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();









  }
  public void outsource() {
    AES128Decrypt decryptor = new AES128Decrypt(key, ciphertext);
    plaintext = decryptor.outsource();
  }
  public static byte[] fromHexString(String src) {
    byte[] bytes = new BigInteger("10" + src.replaceAll("\\s", ""), 16).toByteArray();
    return Arrays.copyOfRange(bytes, 1, bytes.length);
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
