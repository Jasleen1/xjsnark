package xjsnark.strings;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.UnsignedInteger;
import util.Util;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;
import java.util.Arrays;
import backend.eval.CircuitEvaluator;

public class StringProcessing extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see examples) 
    new StringProcessing();
  }

  public StringProcessing() {
    super("StringProcessing");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        byte[] strArray = fromHexString("485454502f312e3120323030204f4b0d0a455461673a202238666638613338626661343336343137616131343631663863333936396264653262643734383337220d0a782d6170702d75736167653a207b2263616c6c5f636f756e74223a362c22746f74616c5f63707574696d65223a302c22746f74616c5f74696d65223a317d0d0a436f6e74656e742d547970653a206170706c69636174696f6e2f6a736f6e3b20636861727365743d5554462d380d0a66616365626f6f6b2d6170692d76657273696f6e3a2076332e320d0a5374726963742d5472616e73706f72742d53656375726974793a206d61782d6167653d31353535323030303b207072656c6f61640d0a507261676d613a206e6f2d63616368650d0a782d66622d7265763a20313030303631383236320d0a4163636573732d436f6e74726f6c2d416c6c6f772d4f726967696e3a202a0d0a43616368652d436f6e74726f6c3a20707269766174652c206e6f2d63616368652c206e6f2d73746f72652c206d7573742d726576616c69646174650d0a782d66622d74726163652d69643a20436554577478562f3175390d0a782d66622d726571756573742d69643a20413972724645356c3655374b6151765644655f5f55534a0d0a457870697265733a205361742c203031204a616e20323030302030303a30303a303020474d540d0a582d46422d44656275673a205279375079336874383253357075414845722f6d366a44456f30744637574574554d6d774a6a57323961536f68434f396a5a502b324231514943634f6e4438492b345933366a70306c4164575862614e43576f6a62413d3d0d0a446174653a205468752c2031382041707220323031392031383a30303a353120474d540d0a436f6e6e656374696f6e3a206b6565702d616c6976650d0a436f6e74656e742d4c656e6774683a2034370d0a0d0a7b226964223a2231323432313636373932353837343939222c226e616d65223a2244656570616b204d6172616d227d");
        int len = strArray.length;
        for (int i = 0; i < strArray.length; i++) {
          str[i].mapValue(BigInteger.valueOf((strArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        for (int i = strArray.length; i < MAX_INPUT_SIZE; i++) {
          str[i].mapValue(BigInteger.valueOf(0), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        length.mapValue(BigInteger.valueOf(len), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        System.out.println(len);
      }
      public void post() {
        System.out.println(dnlPos.getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()));
        System.out.println(msgLen.getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()));
      }

    });

  }



  public void __init() {
    str = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{MAX_INPUT_SIZE}, 8);
    length = new UnsignedInteger(32, new BigInteger("0"));
    dnlPos = new UnsignedInteger(32, new BigInteger("0"));
    msgLen = new UnsignedInteger(32, new BigInteger("0"));
  }

  public UnsignedInteger[] str;
  public UnsignedInteger length;
  public UnsignedInteger dnlPos;
  public UnsignedInteger msgLen;

  public static int MAX_INPUT_SIZE = 1000;
  public static int CAR_RET = 0x0d;
  public static int NEW_LINE = 0x0a;
  public static int LEFT_BRACE = 0x7b;
  public static int RIGHT_BRACE = 0x7d;
  @Override
  public void __defineInputs() {
    super.__defineInputs();
    length = UnsignedInteger.createInput(this, 32);


    str = (UnsignedInteger[]) UnsignedInteger.createInputArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(str), 8);









  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, dnlPos);
    UnsignedInteger.makeOutput(this, msgLen);







  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();















  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();












  }
  public void outsource() {
    // Entry point for the circuit. Input and witness arrays/structs must be instantiated outside this method 
    UnsignedInteger CR = UnsignedInteger.instantiateFrom(8, CAR_RET).copy(8);
    UnsignedInteger NL = UnsignedInteger.instantiateFrom(8, NEW_LINE).copy(8);
    UnsignedInteger[] DNL = {CR.copy(8), NL.copy(8), CR.copy(8), NL.copy(8)};

    UnsignedInteger LB = UnsignedInteger.instantiateFrom(8, LEFT_BRACE).copy(8);
    UnsignedInteger RB = UnsignedInteger.instantiateFrom(8, RIGHT_BRACE).copy(8);

    UnsignedInteger cur = new UnsignedInteger(8, new BigInteger("0"));
    UnsignedInteger[] lastThree = {new UnsignedInteger(8, new BigInteger("0")), new UnsignedInteger(8, new BigInteger("0")), new UnsignedInteger(8, new BigInteger("0"))};

    for (int i = 0; i < MAX_INPUT_SIZE; i++) {
      {
        Bit bit_a0l0u = UnsignedInteger.instantiateFrom(32, i).isLessThan(length).copy();
        boolean c_a0l0u = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0l0u);
        if (c_a0l0u) {
          if (bit_a0l0u.getConstantValue()) {
            {
              Bit bit_a0a0a2a0a11a02 = checkSubString(i, DNL).copy();
              boolean c_a0a0a2a0a11a02 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0a2a0a11a02);
              if (c_a0a0a2a0a11a02) {
                if (bit_a0a0a2a0a11a02.getConstantValue()) {
                  dnlPos.assign(UnsignedInteger.instantiateFrom(32, i), 32);
                } else {

                }
              } else {
                ConditionalScopeTracker.pushMain();
                ConditionalScopeTracker.push(bit_a0a0a2a0a11a02);
                dnlPos.assign(UnsignedInteger.instantiateFrom(32, i), 32);

                ConditionalScopeTracker.pop();

                ConditionalScopeTracker.push(new Bit(true));

                ConditionalScopeTracker.pop();
                ConditionalScopeTracker.popMain();
              }

            }
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0l0u);
          {
            Bit bit_a0a0l0u = checkSubString(i, DNL).copy();
            boolean c_a0a0l0u = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0l0u);
            if (c_a0a0l0u) {
              if (bit_a0a0l0u.getConstantValue()) {
                dnlPos.assign(UnsignedInteger.instantiateFrom(32, i), 32);
              } else {

              }
            } else {
              ConditionalScopeTracker.pushMain();
              ConditionalScopeTracker.push(bit_a0a0l0u);
              dnlPos.assign(UnsignedInteger.instantiateFrom(32, i), 32);

              ConditionalScopeTracker.pop();

              ConditionalScopeTracker.push(new Bit(true));

              ConditionalScopeTracker.pop();
              ConditionalScopeTracker.popMain();
            }

          }

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }

  }
  public void expect(UnsignedInteger a, UnsignedInteger b) {
    a.forceEqual(b);
  }
  public Bit checkSubString(int index, UnsignedInteger[] substr) {
    Bit ret = Bit.instantiateFrom(true).copy();
    for (int i = index; i < index + substr.length; i++) {
      ret.assign(ret.and(str[i].isEqualTo(substr[i - index])));
    }
    return ret;
  }
  public static byte[] fromHexString(String src) {
    byte[] bytes = new BigInteger("10" + src.replaceAll("\\s", ""), 16).toByteArray();
    return Arrays.copyOfRange(bytes, 1, bytes.length);
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
